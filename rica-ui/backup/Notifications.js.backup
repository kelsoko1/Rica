import React, { useEffect } from 'react';
import { useNotifications } from './NotificationProvider';
import './Notifications.css';

// Individual notification component
const Notification = ({ id, type, message, onClose, autoClose = true, duration = 5000 }) => {
  useEffect(() => {
    // Auto close notification after duration
    let timer;
    if (autoClose) {
      timer = setTimeout(() => {
        onClose(id);
      }, duration);
    }
    
    return () => {
      if (timer) {
        clearTimeout(timer);
      }
    };
  }, [id, onClose, autoClose, duration]);
  
  // Get icon based on type
  const getIcon = () => {
    switch (type) {
      case 'success':
        return '‚úÖ';
      case 'error':
        return '‚ùå';
      case 'warning':
        return '‚ö†Ô∏è';
      case 'info':
        return '‚ÑπÔ∏è';
      default:
        return 'üìù';
    }
  };
  
  return (
    <div className={`notification notification-${type}`}>
      <div className="notification-icon">
        {getIcon()}
      </div>
      <div className="notification-content">
        <div className="notification-message">{message}</div>
      </div>
      <button className="notification-close" onClick={() => onClose(id)}>
        √ó
      </button>
    </div>
  );
};

// Notifications container component
const Notifications = ({ notifications = [], removeNotification }) => {
  // Get notification methods if not provided as props
  const notificationContext = useNotifications();
  
  // Use provided props or context values
  const notificationList = notifications.length > 0 ? notifications : notificationContext.notifications;
  const handleRemoveNotification = removeNotification || notificationContext.removeNotification;
  
  // Add notification methods to window object for global access
  useEffect(() => {
    if (!window.ricaNotifications) {
      window.ricaNotifications = {
        success: notificationContext.success,
        error: notificationContext.error,
        warning: notificationContext.warning,
        info: notificationContext.info,
      };
    }
    
    return () => {
      // Clean up
      delete window.ricaNotifications;
    };
  }, [notificationContext]);
  
  // Listen for WebSocket events to show notifications
  useEffect(() => {
    const webSocketClient = window.webSocketClient;
    
    if (!webSocketClient) {
      return;
    }
    
    // Device events
    const handleDevicesDiscovered = (data) => {
      window.ricaNotifications.success(`${data.count} devices discovered`);
    };
    
    const handleDeviceConnected = (data) => {
      window.ricaNotifications.success(`Device ${data.deviceName || data.deviceId} connected`);
    };
    
    const handleDeviceDisconnected = (data) => {
      window.ricaNotifications.info(`Device ${data.deviceName || data.deviceId} disconnected`);
    };
    
    // Data collection events
    const handleDataCollected = (data) => {
      window.ricaNotifications.success(`Data collected from ${data.count} devices`);
    };
    
    const handleDataSentToOpenCTI = (data) => {
      window.ricaNotifications.info(`Data sent to OpenCTI (${data.count} devices)`);
    };
    
    const handleDataSentToOpenBAS = (data) => {
      window.ricaNotifications.info(`Data sent to OpenBAS (${data.count} devices)`);
    };
    
    // Error events
    const handleError = (data) => {
      window.ricaNotifications.error(data.error || 'An error occurred');
    };
    
    // Add event listeners
    webSocketClient.on('devices:discovered', handleDevicesDiscovered);
    webSocketClient.on('device:connected', handleDeviceConnected);
    webSocketClient.on('device:disconnected', handleDeviceDisconnected);
    webSocketClient.on('data:collected', handleDataCollected);
    webSocketClient.on('data:sentToOpenCTI', handleDataSentToOpenCTI);
    webSocketClient.on('data:sentToOpenBAS', handleDataSentToOpenBAS);
    webSocketClient.on('error', handleError);
    webSocketClient.on('deviceDiscovery:error', handleError);
    webSocketClient.on('dataCollection:error', handleError);
    
    // Clean up event listeners
    return () => {
      webSocketClient.off('devices:discovered', handleDevicesDiscovered);
      webSocketClient.off('device:connected', handleDeviceConnected);
      webSocketClient.off('device:disconnected', handleDeviceDisconnected);
      webSocketClient.off('data:collected', handleDataCollected);
      webSocketClient.off('data:sentToOpenCTI', handleDataSentToOpenCTI);
      webSocketClient.off('data:sentToOpenBAS', handleDataSentToOpenBAS);
      webSocketClient.off('error', handleError);
      webSocketClient.off('deviceDiscovery:error', handleError);
      webSocketClient.off('dataCollection:error', handleError);
    };
  }, []);
  
  // If no notifications, don't render anything
  if (notificationList.length === 0) {
    return null;
  }
  
  return (
    <div className="notifications-container">
      {notificationList.map(notification => (
        <Notification
          key={notification.id}
          id={notification.id}
          type={notification.type}
          message={notification.message}
          onClose={handleRemoveNotification}
          autoClose={notification.autoClose}
          duration={notification.duration}
        />
      ))}
    </div>
  );
};

export default Notifications;
